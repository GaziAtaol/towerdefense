--- a/include/SFML/System/String.hpp
+++ b/include/SFML/System/String.hpp
@@ -28,12 +28,215 @@
 ////////////////////////////////////////////////////////////
 // Headers
 ////////////////////////////////////////////////////////////
+#include <SFML/Config.hpp>
 #include <SFML/System/Export.hpp>
 #include <SFML/System/Utf.hpp>
 #include <iterator>
 #include <locale>
 #include <string>
 
+#if defined(_LIBCPP_VERSION)
+#include <compare>
+#include <cstddef>
+#include <cstdint>
+#include <cstring>
+#include <cwchar>
+#include <ios>
+#include <istream>
+
+namespace std
+{
+template <>
+struct char_traits<sf::Uint8>
+{
+    using char_type = sf::Uint8;
+    using int_type = int;
+    using off_type = std::streamoff;
+    using pos_type = std::streampos;
+    using state_type = std::mbstate_t;
+    using comparison_category = std::strong_ordering;
+
+    static void assign(char_type& r, const char_type& a) noexcept { r = a; }
+    static constexpr bool eq(char_type c1, char_type c2) noexcept { return c1 == c2; }
+    static constexpr bool lt(char_type c1, char_type c2) noexcept { return c1 < c2; }
+    static int compare(const char_type* s1, const char_type* s2, std::size_t n) noexcept
+    {
+        for (std::size_t i = 0; i < n; ++i)
+        {
+            if (lt(s1[i], s2[i]))
+                return -1;
+            if (lt(s2[i], s1[i]))
+                return 1;
+        }
+        return 0;
+    }
+    static std::size_t length(const char_type* s) noexcept
+    {
+        std::size_t len = 0;
+        while (!eq(s[len], char_type()))
+            ++len;
+        return len;
+    }
+    static const char_type* find(const char_type* s, std::size_t n, const char_type& a) noexcept
+    {
+        for (std::size_t i = 0; i < n; ++i)
+            if (eq(s[i], a))
+                return s + i;
+        return nullptr;
+    }
+    static char_type* move(char_type* s1, const char_type* s2, std::size_t n) noexcept
+    {
+        if (s1 == s2)
+            return s1;
+        std::memmove(s1, s2, n * sizeof(char_type));
+        return s1;
+    }
+    static char_type* copy(char_type* s1, const char_type* s2, std::size_t n) noexcept
+    {
+        std::memcpy(s1, s2, n * sizeof(char_type));
+        return s1;
+    }
+    static char_type* assign(char_type* s, std::size_t n, char_type a) noexcept
+    {
+        for (std::size_t i = 0; i < n; ++i)
+            s[i] = a;
+        return s;
+    }
+    static constexpr char_type to_char_type(int_type c) noexcept { return static_cast<char_type>(c); }
+    static constexpr int_type to_int_type(char_type c) noexcept { return static_cast<int_type>(c); }
+    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept { return c1 == c2; }
+    static constexpr int_type eof() noexcept { return -1; }
+    static constexpr int_type not_eof(int_type c) noexcept { return eq_int_type(c, eof()) ? 0 : c; }
+};
+
+template <>
+struct char_traits<sf::Uint16>
+{
+    using char_type = sf::Uint16;
+    using int_type = std::uint_least32_t;
+    using off_type = std::streamoff;
+    using pos_type = std::u16streampos;
+    using state_type = std::mbstate_t;
+    using comparison_category = std::strong_ordering;
+
+    static void assign(char_type& r, const char_type& a) noexcept { r = a; }
+    static constexpr bool eq(char_type c1, char_type c2) noexcept { return c1 == c2; }
+    static constexpr bool lt(char_type c1, char_type c2) noexcept { return c1 < c2; }
+    static int compare(const char_type* s1, const char_type* s2, std::size_t n) noexcept
+    {
+        for (std::size_t i = 0; i < n; ++i)
+        {
+            if (lt(s1[i], s2[i]))
+                return -1;
+            if (lt(s2[i], s1[i]))
+                return 1;
+        }
+        return 0;
+    }
+    static std::size_t length(const char_type* s) noexcept
+    {
+        std::size_t len = 0;
+        while (!eq(s[len], char_type()))
+            ++len;
+        return len;
+    }
+    static const char_type* find(const char_type* s, std::size_t n, const char_type& a) noexcept
+    {
+        for (std::size_t i = 0; i < n; ++i)
+            if (eq(s[i], a))
+                return s + i;
+        return nullptr;
+    }
+    static char_type* move(char_type* s1, const char_type* s2, std::size_t n) noexcept
+    {
+        if (s1 == s2)
+            return s1;
+        std::memmove(s1, s2, n * sizeof(char_type));
+        return s1;
+    }
+    static char_type* copy(char_type* s1, const char_type* s2, std::size_t n) noexcept
+    {
+        std::memcpy(s1, s2, n * sizeof(char_type));
+        return s1;
+    }
+    static char_type* assign(char_type* s, std::size_t n, char_type a) noexcept
+    {
+        for (std::size_t i = 0; i < n; ++i)
+            s[i] = a;
+        return s;
+    }
+    static constexpr char_type to_char_type(int_type c) noexcept { return static_cast<char_type>(c); }
+    static constexpr int_type to_int_type(char_type c) noexcept { return static_cast<int_type>(c); }
+    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept { return c1 == c2; }
+    static constexpr int_type eof() noexcept { return static_cast<int_type>(-1); }
+    static constexpr int_type not_eof(int_type c) noexcept { return eq_int_type(c, eof()) ? static_cast<int_type>(0) : c; }
+};
+
+template <>
+struct char_traits<sf::Uint32>
+{
+    using char_type = sf::Uint32;
+    using int_type = std::uint_least32_t;
+    using off_type = std::streamoff;
+    using pos_type = std::u32streampos;
+    using state_type = std::mbstate_t;
+    using comparison_category = std::strong_ordering;
+
+    static void assign(char_type& r, const char_type& a) noexcept { r = a; }
+    static constexpr bool eq(char_type c1, char_type c2) noexcept { return c1 == c2; }
+    static constexpr bool lt(char_type c1, char_type c2) noexcept { return c1 < c2; }
+    static int compare(const char_type* s1, const char_type* s2, std::size_t n) noexcept
+    {
+        for (std::size_t i = 0; i < n; ++i)
+        {
+            if (lt(s1[i], s2[i]))
+                return -1;
+            if (lt(s2[i], s1[i]))
+                return 1;
+        }
+        return 0;
+    }
+    static std::size_t length(const char_type* s) noexcept
+    {
+        std::size_t len = 0;
+        while (!eq(s[len], char_type()))
+            ++len;
+        return len;
+    }
+    static const char_type* find(const char_type* s, std::size_t n, const char_type& a) noexcept
+    {
+        for (std::size_t i = 0; i < n; ++i)
+            if (eq(s[i], a))
+                return s + i;
+        return nullptr;
+    }
+    static char_type* move(char_type* s1, const char_type* s2, std::size_t n) noexcept
+    {
+        if (s1 == s2)
+            return s1;
+        std::memmove(s1, s2, n * sizeof(char_type));
+        return s1;
+    }
+    static char_type* copy(char_type* s1, const char_type* s2, std::size_t n) noexcept
+    {
+        std::memcpy(s1, s2, n * sizeof(char_type));
+        return s1;
+    }
+    static char_type* assign(char_type* s, std::size_t n, char_type a) noexcept
+    {
+        for (std::size_t i = 0; i < n; ++i)
+            s[i] = a;
+        return s;
+    }
+    static constexpr char_type to_char_type(int_type c) noexcept { return static_cast<char_type>(c); }
+    static constexpr int_type to_int_type(char_type c) noexcept { return static_cast<int_type>(c); }
+    static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept { return c1 == c2; }
+    static constexpr int_type eof() noexcept { return static_cast<int_type>(-1); }
+    static constexpr int_type not_eof(int_type c) noexcept { return eq_int_type(c, eof()) ? static_cast<int_type>(0) : c; }
+};
+} // namespace std
+#endif
+
 
 namespace sf
 {
